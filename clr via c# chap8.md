# chap8 方法

## 1 实例构造器和类（引用类型）

	创建引用类型的实例时，clr会进行以下步骤：
	1. 为实例字段分配内存（分配的内存被归零或null）
	2. 初始化对象的**附加字段**类型对象指针和同步块索引
	3. 调用构造器给字段赋值
	
	

> 实例构造器永远不能被继承，不能使用virtual,new abstract override sealed，

> 默认生成的构造器只是简单地调用了父对象的无参数构造器
	
	少数情况下可以绕过构造器创建实例
	+ 使用Object.MemberwiseClone方法
	+ 使用运行时序列化器反序列化对象
	
	**不要在构造函数中调用虚方法**，会导致无法预测的行为

C# 可以在定义类型时的同时赋值：
    
    private int m_x = 10;

而实际上这只是一种便捷的语法，C#编译器在幕后会进行转换：在类的构造函数中去执行这行代码，再调用基类的构造器，再然后才是类自身构造器的代码，因此如果有太多这种语法和太多的构造器的时候编译器的工作量还是有点大的
    
## 2 实例构造器和结构（值类型）
1. 值类型其实并不需要定义构造器
1. C#不会为值类型生成默认的构造器
1. Clr允许为值类型定义构造器，但必须显式调用才会执行
1. C#不会主动生成代码去调用值类型的无参构造器

## 3 类型构造器
类型构造器用于设置类型的初始状态
他的调用总是由clr负责

JIT编译器在每调用一个方法时，会检查引用了哪些类型，如果有任何一个类型定义了类型构造器，JIT编译器就会检查当前AppDomain下该构造器是否已经执行过，没有则在生成的本机代码中添加对他的调用（使用互斥锁保证线程安全，只会执行一次）。

定义静态变量时赋值：
    private static int m_x = 10;
同上面一节一样，C#编译器在幕后也会生成静态构造器去执行初始化操作

## 4 操作符重载方法
clr不知道操作符，也不知道操作符重载，编译器在遇见操作符时会生成对应的代码让clr执行。


