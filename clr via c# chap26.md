# ch26 Windows线程基础

## Windows为什么要支持线程
使用单个执行线程的操作系统（早期16位的Windows）在某个应用程序出现无响应时不得不重启整个机器。

Microsoft在设计新的OS内核时提出了进程的概念，将每一个应用程序的实例都放到各自的进程中运行。进程与进程彼此隔离，进程与OS内核也隔离从而使得应用程序的实例更加健壮，系统更加安全。

有了进程后在应用程序进入死循环时CPU仍会进入死循环，为了解决这个问题Microsoft使用线程技术。
>线程的职责是对CPU进行虚拟化。

Windows为每个进程提供一个专有线程，当该进程进入死循环时，Windows的其他线程仍会继续工作。

## 线程的开销
线程对CPU进行虚拟化，它具有空间和时间上的开销：

* 线程内核对象
	
包含对线程的描述属性、线程上下文

* 线程环境块

内存页、线程异常处理链首、线程本地存储数据

* 用户模式栈

线程栈。用来存储传递给方法的实参和局部变量，Windows默认为每个线程分配1M空间
* 内核模式栈

运行Windows内核时用来存储方法的实参、局部变量，用户模式的代码不能修改其中的值

* DLL线程连接和线程分离通知

Windows的策略是，每创建一个线程，都会调用所在进程中加载的非托管DLL的dllmain方法传递一个DLL_THREAD_ATTACH标识。然后在线程被销毁时再调用一次非托管DLL的dllmain方法，传递一个DLL_THREAD_DETACH标识

因为Windows确保在任何一个时刻只将一个线程分配给一个CPU，该线程执行一个“时间片”的时间，之后CPU将挂起该线程转而执行另外一个线程。这让Windows看起来像一个多任务的操作系统，而CPU执行线程切换同样需要一些开销：

* 线程的时间片到期时将CPU寄存器中的信息保存到该线程的内核对象中
* 从线程集合中获取下一个需要执行的线程，如果线程是在另外一个进程中，还需要切换虚拟地址空间
* 将所选线程的上下文中的数据加载到CPU寄存器中

在进行垃圾回收时，CLR必须挂起（暂停）所有的线程，遍历它们栈来查找根、再遍历栈、再恢复线程。所以减少线程的数量会显著提高垃圾回收的性能

遇到调试断点时，Windows会挂起该进程下的所有线程，在单步执行或者继续运行应用程序时恢复所有线程，所以线程越多调试时的体验越差。

## 停止疯狂

线程是一种宝贵的资源，应该合理、高效的使用。

## CPU的发展趋势

CPU运行速度过快后会产生大量的热量，并不能无限制的进行提升。因此现在厂商更多的使用的是减小硅芯片上的晶体管的体积，让芯片上可以容纳多个处理器。这样的话，如果我们软件能合理地使用多个CPU内核，就能使软件运行得更高效。

## CLR线程和Windows线程

clr线程就是windows线程

## 使用专用线程执行异步计算

使用创建Thread类的实例，并传递一个委托，调用start方法来开启一个线程。

强烈建议避免使用这种方法，应该尽量使用线程池来执行异步的计算操作

## 使用线程的理由

* 将长时操作交给另外的线程去做，使用户得到响应灵敏的UI
* 每个CPU在同一时刻执行一个线程，那么在多核CPU上可以真正同时执行多个线程

## 线程调度和优先级
## 前台线程和后台线程
## 继续学习
